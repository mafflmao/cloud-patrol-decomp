using System;
using System.Collections;
using UnityEngine;

public class ToyLinkManager : SingletonMonoBehaviour
{
	private const float TimeoutTime = 10f;

	private const string NoInternetConnectivityError = "TOYLINK_ERROR_NOT_ONLINE";

	private const string NoBedrockConnectionError = "TOYLINK_ERROR_NO_BEDROCK";

	private const string IncorrectToyCodeError = "TOYLINK_ERROR_WRONG_TOY";

	private const string TaskTimeoutError = "TOYLINK_ERROR_TIMEOUT";

	private const string UnlockedTooManyTimesError = "TOYLINK_ERROR_TOO_MANY_UNLOCKS";

	private const string InvalidCodeError = "TOYLINK_ERROR_INVALID_CODE";

	private const string UnknownErrorCodeError = "TOYLINK_ERROR_UNEXPECTED_ERROR";

	private static readonly ILogger _log = LogBuilder.Instance.GetLogger(typeof(ToyLinkManager), LogLevel.Debug);

	public ErrorDialog linkFailedDialogPrefab;

	public static ToyLinkManager Instance
	{
		get
		{
			return SingletonMonoBehaviour.GetAutoGeneratedSingletonInstance<ToyLinkManager>();
		}
	}

	protected override void AwakeOnce()
	{
		base.AwakeOnce();
		UnityEngine.Object.DontDestroyOnLoad(this);
	}

	private void OnEnable()
	{
		StateManager.StateDeactivated += HandleStateDeactivated;
	}

	private void OnDisable()
	{
		StateManager.StateDeactivated -= HandleStateDeactivated;
	}

	private void HandleStateDeactivated(object sender, StateEventArgs e)
	{
		Dismiss();
	}

	private void Dismiss()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void BeginToyLink(ILinkable linkableToy, string webcode, Action successAction)
	{
		StartCoroutine(CheckValue(linkableToy, webcode, successAction));
	}

	private IEnumerator CheckValue(ILinkable linkableToy, string webcode, Action successAction)
	{
		_log.LogDebug("CheckValue(...)");
		UIManager.instance.blockInput = true;
		_log.Log("Starting check for code '{0}' for toy '{1}'", webcode, linkableToy.ToyLinkDisplayName);
		if (Application.internetReachability == NetworkReachability.NotReachable)
		{
			_log.Log("Internet is not reachable... Aborting.");
			FailAndShowError(linkableToy.ToyLinkDisplayName, LocalizationManager.Instance.GetString("TOYLINK_ERROR_NOT_ONLINE"));
			yield break;
		}
		UIManager.instance.blockInput = true;
		LoadingPanel panel = LoadingPanel.InstanceAutoCreate;
		panel.DismissIfNotLoading = false;
		panel.text.Text = LocalizationManager.Instance.GetString("TOY_LINK_STATUS_CONNECTING");
		bool unlockSuccessfull = false;
		if (Application.isEditor)
		{
			yield return new WaitForSeconds(2f);
			if (webcode.StartsWith("2011"))
			{
				_log.Log("Pretending code is for a 2011 skylander.");
				unlockSuccessfull = true;
				linkableToy.UnlockFromToy(1u);
			}
			else if (webcode.StartsWith("2012L"))
			{
				_log.Log("Pretending code is for a 2012 Lightcore skylander.");
				unlockSuccessfull = true;
				linkableToy.UnlockFromToy(4u);
			}
			else if (webcode.StartsWith("2012"))
			{
				_log.Log("Pretending code is for a 2012 skylander.");
				unlockSuccessfull = true;
				linkableToy.UnlockFromToy(2u);
			}
		}
		else
		{
			_log.Log("Waiting until bedrock is fully connected");
			Bedrock.Reconnect();
			yield return StartCoroutine(WaitForBedrockConnection());
			if (!Bedrock.getUserConnectionStatus().IsOnline())
			{
				_log.Log("Failed to connect to bedrock.");
				FailAndShowError(linkableToy.ToyLinkDisplayName, LocalizationManager.Instance.GetString("TOYLINK_ERROR_NO_BEDROCK"));
			}
			panel.text.Text = LocalizationManager.Instance.GetString("TOY_LINK_STATUS_CHECKING");
			_log.Log("Performing unlock of item on remote server...");
			short taskHandle = Bedrock.StartUnlockContent(Bedrock.brLobbyServerTier.BR_LOBBY_SERVER_FRANCHISE, webcode);
			using (BedrockTask unlockContentTask = new BedrockTask(taskHandle))
			{
				yield return StartCoroutine(unlockContentTask.WaitForTaskToCompleteOrTimeoutCoroutine());
				if (unlockContentTask.Status != Bedrock.brTaskStatus.BR_TASK_SUCCESS)
				{
					_log.Log("Failed to unlock content");
					FailBedrockTask(unlockContentTask.Handle, linkableToy.ToyLinkDisplayName, webcode);
					yield break;
				}
				_log.Log("Succesfully unlocked.");
			}
			_log.Log("Connected, getting list of usnlocked content.");
			Bedrock.brContentUnlockInfo[] unlockInfo = Bedrock.ListUnlockedContent(Bedrock.brLobbyServerTier.BR_LOBBY_SERVER_FRANCHISE, 256u);
			_log.LogDebug("Checking {0} pieces of content associated with this account:", unlockInfo.Length);
			Bedrock.brContentUnlockInfo[] array = unlockInfo;
			for (int i = 0; i < array.Length; i++)
			{
				Bedrock.brContentUnlockInfo contentUnlockInfo = array[i];
				_log.LogDebug("  Linked Content: Toy={0},SubType={1}", contentUnlockInfo.contentKey, contentUnlockInfo.subType);
				if (linkableToy.MatchesToyAndSubtype(contentUnlockInfo.contentKey, contentUnlockInfo.subType))
				{
					_log.LogDebug("    Matches our current toy! Unlocking!");
					linkableToy.UnlockFromToy(contentUnlockInfo.subType);
					unlockSuccessfull = true;
				}
			}
		}
		UIManager.instance.blockInput = false;
		panel.Dismiss();
		if (unlockSuccessfull)
		{
			_log.Log("Unlock for code '{0}' succeeded!", webcode);
			Dismiss();
			if (successAction != null)
			{
				_log.LogDebug("Firing SuccessAction");
				successAction();
			}
		}
		else
		{
			FailAndShowError(errorMessage: LocalizationManager.Instance.GetFormatString("TOYLINK_ERROR_WRONG_TOY", linkableToy.ToyLinkDisplayName), toyName: linkableToy.ToyLinkDisplayName);
		}
	}

	private void FailBedrockTask(short taskHandle, string toyName, string enteredCode)
	{
	}

	private void FailAndShowError(string toyName, string errorMessage)
	{
		SwrveEventsProgression.ToyRegistrationServerFailed(toyName, errorMessage);
		if (LoadingPanel.InstanceNoAutocreate != null)
		{
			LoadingPanel.InstanceNoAutocreate.Dismiss();
		}
		UIManager.instance.blockInput = false;
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(linkFailedDialogPrefab.gameObject);
		ErrorDialog component = gameObject.GetComponent<ErrorDialog>();
		component.Display(LocalizationManager.Instance.GetString("TOYLINK_ERROR_TITLE_TRY_AGAIN"), errorMessage, LocalizationManager.Instance.GetString("TOYLINK_ERROR_BUTTON_RETRY"), null);
	}

	public void CanToyLink(ILinkable linkableToy, string webcode, Action onYesAction)
	{
		StartCoroutine(CheckIfCanUnlock(linkableToy, webcode, onYesAction));
	}

	private IEnumerator CheckIfCanUnlock(ILinkable linkableToy, string webcode, Action onYesAction)
	{
		_log.LogDebug("CheckIfCanUnlock(...)");
		UIManager.instance.blockInput = true;
		_log.Log("Starting check for code '" + webcode + "'");
		if (Application.internetReachability == NetworkReachability.NotReachable)
		{
			_log.Log("Internet is not reachable... Aborting.");
			FailAndShowError(linkableToy.ToyLinkDisplayName, LocalizationManager.Instance.GetString("TOYLINK_ERROR_NOT_ONLINE"));
			yield break;
		}
		UIManager.instance.blockInput = true;
		_log.Log("Waiting until bedrock is fully connected");
		Bedrock.Reconnect();
		yield return StartCoroutine(WaitForBedrockConnection());
		if (!Bedrock.getUserConnectionStatus().IsOnline())
		{
			_log.Log("Failed to connect to bedrock.");
			FailAndShowError(linkableToy.ToyLinkDisplayName, LocalizationManager.Instance.GetString("TOYLINK_ERROR_NO_BEDROCK"));
		}
		_log.Log("Connected to bedrock!");
		Bedrock.brContentUnlockInfo contentInfo = default(Bedrock.brContentUnlockInfo);
		contentInfo.init();
		_log.Log("Checking for code validity...");
		short taskHandle = Bedrock.StartAsyncGetContentKeyFromLicense(Bedrock.brLobbyServerTier.BR_LOBBY_SERVER_FRANCHISE, webcode);
		using (BedrockTask getContentTask = new BedrockTask(taskHandle))
		{
			yield return StartCoroutine(getContentTask.WaitForTaskToCompleteOrTimeoutCoroutine());
			_log.Log("Checking for success...");
			if (getContentTask.Status != Bedrock.brTaskStatus.BR_TASK_SUCCESS)
			{
				_log.Log("Failed to get content key from license");
				FailBedrockTask(getContentTask.Handle, linkableToy.ToyLinkDisplayName, webcode);
				yield break;
			}
			_log.Log("Checking for content key");
			if (!Bedrock.FinishAsyncGetContentKeyFromLicense(getContentTask.Handle, ref contentInfo))
			{
				_log.Log("Failed to get results from GetContentKeyFromLicense");
				FailBedrockTask(getContentTask.Handle, linkableToy.ToyLinkDisplayName, webcode);
				yield break;
			}
			_log.Log("Content Key retrieved: " + contentInfo.ToString());
		}
		if (linkableToy.MatchesToyAndSubtype(contentInfo.contentKey, contentInfo.subType) && onYesAction != null)
		{
			onYesAction();
		}
		UIManager.instance.blockInput = false;
	}

	private IEnumerator WaitForBedrockConnection()
	{
		DateTime startupStartTime = DateTime.Now;
		DateTime startUpWaitTime = startupStartTime + TimeSpan.FromSeconds(10.0);
		while (DateTime.Now < startUpWaitTime && !Bedrock.getUserConnectionStatus().IsOnline())
		{
			Bedrock.ForceUpdate();
			yield return new WaitForEndOfFrame();
		}
	}
}
